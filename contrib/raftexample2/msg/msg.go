package msg

import (
	"bufio"
	"encoding/binary"
	"fmt"
	"io"
	"strconv"
)

/*
	1. Package Description

	The msg package contains multiple files. msg.proto defines Rabia's messaging objects' formats, including Command,
	ConsensusObj, and Msg objects, where ConsensusObj is embedded in Msg for server-server transmission.

	msg.go defines several messaging-related helper functions that facilitate ConsensusObj comparison, Command
	serialization, and Msg serialization.

	msg.pb.go, defines the serialization & de-serialization schema of messaging objects, and it is auto-generated by
	gogo-protobuf based on definitions in msg.proto.

	2. Notes on consensus objects (ConsensusObj)

	We assume a ConsensusObj can be uniquely identified through its ProId and its ProSeq field; if two objects have the
	same ProId fields and the same ProSeq fields, we consider they are the same object. Therefore, the "primary key" for
	identifying an ConsensusObj object is the concatenation of the ProSeq field and the ProSeq field.

	Determine whether two consensus objects c1 and c2 are equal:
		c1.GetIdSeq() == c2.GetIdSeq()
	or
		ProxySeqIdEqual(c1, c2)

	Determine whether consensus object c1 is "less-than" c2:
	The "less-than" relation is defined below, where << stands for "less-than" and "!<<" stands for not-less-than:

	if c1.ProSeq < c2.ProSeq:
		c1 << c2
	else if c1.ProSeq == c2.ProSeq:
		if c1.ProId < c2.ProId:
			c1 << c2
		else (c1.ProId >= c2.ProId):
			c1 !<< c2
	else // c1.ProSeq > c2.ProSeq:
		c1 !<< c2

	3. Notes on on-wire data format:

	We send and receive messages through native TCP channels. Since we did not use the gob package to serialize and send
	messages (which are too slow for our purpose) but use gogo-protobuf to serialize instead, we need to define how
	messages are represented on wires. Say the length of a message in bytes is N, we always use 4 bytes to send the
	number N, and then send those N bytes. We do so for the next message so lengths of messages and the actual data
	appear alternatives on wire. At the reader end, we first read 4 bytes to determine how much we want to read next and
	then read the whole message. In this way, we avoid the possibility of reading a partial message or force all
	messages to have the same size. What we have done here is indeed a common practice.

		Reader <-- the number N | msg 1 (N bytes) | the number M | msg 2 (M bytes) | ... <-- Writer
*/

/*
	vanilla protobuf variables
*/
/*
var ClientRequest = MsgType_ClientRequest
var Proposal = MsgType_Proposal
var State = MsgType_State
var Vote = MsgType_Vote
var ProposalRequest = MsgType_ProposalRequest
var ProposalReply = MsgType_ProposalReply
var Decision = MsgType_Decision

*/

// Returns a consensus object's primary key.
func (c *ConsensusObj) GetIdSeq() string {
	return strconv.Itoa(int(c.ProId)) + "-" + strconv.Itoa(int(c.ProSeq))
}

/*
	Compares whether two consensus objects are equal by comparing their ProId and ProSeq fields.
*/
func ProxySeqIdEqual(c1 *ConsensusObj, c2 *ConsensusObj) bool {
	return c1.ProSeq == c2.ProSeq && c1.ProId == c2.ProId
}

/*
	Compares whether consensus object c1 is less than c2, the less-than relation is defined above.
*/
func ProxySeqIdLessThan(c1 *ConsensusObj, c2 *ConsensusObj) bool {
	return c1.ProSeq < c2.ProSeq || c1.ProSeq == c2.ProSeq && c1.ProId < c2.ProId
}

/*
	Purpose:
		writes a byte array to a bufio.Writer (writer). We first write the length of the byte array and then write the
		actual data.
	Upon errors/exceptions:
		when the reader closes its connection, the writer may or may NOT return any error.
	Parameters:
		writer: the bufio.Writer that binds to the TCP connection
		data: the source of data (the whole array) that will be written
	Return value(s):
		success: it returns the length of the data written and nil as the err field.
		failure: it returns the error message (the int field is not that useful)
*/
func BufWrite(writer *bufio.Writer, data []byte) error {
	lenBuf := make([]byte, 4)
	binary.LittleEndian.PutUint32(lenBuf, uint32(len(data)))
	n1, err := writer.Write(lenBuf)
	if n1 != 4 {
		panic("should not happen")
	}
	if err != nil {
		return err
	}
	n2, err := writer.Write(data)
	if n2 != len(data) {
		panic("should not happen")
	}
	return err
}

/*
	Purpose:
		reads a byte array from a bufio.Reader (reader) to an array called data. We first read the length of the byte
		array and then read the actual data because that's how data and its size are passed from the writer end.
	Upon errors/exceptions:
		if the sender closes the connection, err may become EOF.
	Parameters:
		reader: the bufio.Reader that binds to the TCP connection
		data: where the data should be read to (its size should be larger than the length of incoming data)
	Return value(s):
		success: it returns the length of the data and nil as err.
		failure: it returns the error message (but the int field is not that useful)
*/
func BufRead(reader *bufio.Reader, data []byte) (int, error) {
	lenBuf := make([]byte, 4)
	n1, err := io.ReadFull(reader, lenBuf)
	if n1 != 4 || err != nil {
		return n1, err
	}
	n2 := binary.LittleEndian.Uint32(lenBuf)
	n3, err := io.ReadFull(reader, data[:n2])
	if int(n2) != n3 {
		panic(fmt.Sprint(err, int(n2), n3))
	}
	return n3, nil
}

/*
	Writes and flushes a serialized message -- writes its length and the data and then flush the writer
*/
func WriteFlush(writer *bufio.Writer, data []byte) {
	err := BufWrite(writer, data)
	if err != nil {
		panic("should not happen")
	}
	err = writer.Flush()
	if err != nil {
		panic("should not happen")
	}
}

// todo: err handling in functions below are problematic
// Serializes a Command object and flush its bytes to a writer
func (r *Command) MarshalWriteFlush(writer *bufio.Writer) error {
	data, err := r.Marshal() // gogo-protobuf
	//data, err := proto.Marshal(r) // vanilla protobuf
	err = BufWrite(writer, data)
	err = writer.Flush()
	return err
}

// Reads from a bufio.Reader and then de-serializes bytes to a Command object
func (r *Command) ReadUnmarshal(reader *bufio.Reader, readBuf []byte) error {
	n, err := BufRead(reader, readBuf)
	if err != nil {
		return err
	}
	err = r.Unmarshal(readBuf[:n]) // gogo-protobuf
	//err = proto.Unmarshal(readBuf[:n], r) // vanilla protobuf
	return err
}
